#Region ;**** 参数创建于 AutoIt3Wrapper_GUI ****
#AutoIt3Wrapper_UseX64=n
#AutoIt3Wrapper_Icon=windows.ico
#AutoIt3Wrapper_Res_Comment=WMI 浏览(脚本生成)器
#AutoIt3Wrapper_Res_Description=WMI 浏览(脚本生成)器
#AutoIt3Wrapper_Res_Fileversion=1.01
#AutoIt3Wrapper_Res_LegalCopyright=SvenP
#EndRegion ;**** 参数创建于 AutoIt3Wrapper_GUI ****
#NoTrayIcon
Opt("MustDeclareVars", 1)
; AutoIt ScriptOMatic
; -------------------
;
; AutoIt's counterpart of Microsoft's Scriptomatic
;
; Author:		SvenP
; Date/version:	2005-04-17
; See also:		http://www.microsoft.com/technet/scriptcenter/tools/scripto2.mspx
; Requires:		AutoIt beta version 3.2.11.1 or higher (COM support!!)
;
; GUI generated by AutoBuilder 0.5 Prototype
; mod by thesnoW:
; 1. 中文化
; 2. 支持必须声明变量检查"Opt("MustDeclareVars", 1)"
#include <WindowsConstants.au3>
#include <GuiConstants.au3>

;************************
;* Global State Variables
;************************
Global $g_strCurrentNamespace = "\root\CIMV2"
Global $g_iCurrentNamespaceIndex = 0
Global $g_strWMISource = "localhost"
Global $g_strOutputFormat = "Dialog"

;************************
;* Main GUI
;************************

GUICreate("AutoIt Scriptomatic 工具", 684, 561, (@DesktopWidth - 684) / 2, (@DesktopHeight - 561) / 2, $WS_OVERLAPPEDWINDOW + $WS_VISIBLE + $WS_CLIPSIBLINGS)

Global $GUI_AST_MainGroup = GUICtrlCreateGroup("", 10, 10, 660, 530)
Global $GUI_WMI_NamespaceLabel = GUICtrlCreateLabel("WMI 命名空间(Namespaces)", 20, 30, 150, 20)
Global $GUI_WMI_Namespace = GUICtrlCreateCombo("WMI_Namespaces", 20, 50, 280, 80)
Global $GUI_WMI_ClassLabel = GUICtrlCreateLabel("WMI 类('Class')", 320, 30, 240, 20)
Global $GUI_WMI_Classes = GUICtrlCreateCombo("WMI_Classes", 320, 50, 340, 80)
Global $GUI_AST_ButtonGroup = GUICtrlCreateGroup("", 10, 80, 660, 50)
Global $GUI_AST_Run = GUICtrlCreateButton("运行", 20, 100, 50, 20)
Global $GUI_AST_CIMv2 = GUICtrlCreateButton("CIMv2", 80, 100, 50, 20)
Global $GUI_AST_WMISource = GUICtrlCreateButton("WMISource", 140, 100, 70, 20)
Global $GUI_AST_Open = GUICtrlCreateButton("打开", 220, 100, 60, 20)
Global $GUI_AST_Save = GUICtrlCreateButton("保存", 290, 100, 60, 20)
Global $GUI_AST_Quit = GUICtrlCreateButton("退出", 360, 100, 60, 20)
Global $GUI_AST_OptionGroup = GUICtrlCreateGroup("输出", 430, 80, 240, 50)
Global $GUI_AST_RadioDialog = GUICtrlCreateRadio("对话框", 440, 100, 50, 20)
Global $GUI_AST_RadioText = GUICtrlCreateRadio("文本", 510, 100, 50, 20)
Global $GUI_AST_RadioHTML = GUICtrlCreateRadio("HTML", 570, 100, 50, 20)
Global $GUI_AST_ScriptCode = GUICtrlCreateEdit("载入中,请等待一会儿...", 20, 140, 640, 390)

GUISetState()

; Initial GUI Settings
GUICtrlSetState($GUI_AST_Run, $GUI_DISABLE)
GUICtrlSetState($GUI_AST_Save, $GUI_DISABLE)
GUICtrlSetState($GUI_AST_RadioDialog, $GUI_CHECKED)

; Fill the WMI_Namespaces Combobox
LoadWMINamespaces()

; Fill the WMI_Classes Combobox
HandleNamespaceChange()

While 1
	Local $msg = GUIGetMsg()
	Select
		Case $msg = $GUI_EVENT_CLOSE
			ExitLoop
		Case $msg = $GUI_AST_Quit
			ExitLoop
		Case $msg = $GUI_WMI_Namespace
			HandleNamespaceChange()
		Case $msg = $GUI_WMI_Classes
			ComposeCode()
		Case $msg = $GUI_AST_Run
			RunScript()
		Case $msg = $GUI_AST_Save
			SaveScript()
		Case $msg = $GUI_AST_Open
			OpenScript()
		Case $msg = $GUI_AST_CIMv2
			SetNamespaceToCIMV2()
		Case $msg = $GUI_AST_WMISource
			SetWMIRepository()
		Case $msg = $GUI_AST_RadioDialog Or _
				$msg = $GUI_AST_RadioText Or _
				$msg = $GUI_AST_RadioHTML
			HandleOutputChange()
	EndSelect
WEnd

GUIDelete()

Exit

;********************************************************************
;* LoadWMINamespaces
;********************************************************************
Func LoadWMINamespaces()
	Local $strCsvListOfNamespaces = ""
	Local $strNameSpacesCombo = ""
	Local $strWaitNamespaces = "请稍候, 正在载入 WMI 命名空间"
	GUICtrlSetData($GUI_WMI_Namespace, $strWaitNamespaces, $strWaitNamespaces)

	EnumNamespaces("root", $strCsvListOfNamespaces)

	Local $arrNamespaces = StringSplit($strCsvListOfNamespaces, ",")

	For $strNamespace In $arrNamespaces
		$strNameSpacesCombo = $strNameSpacesCombo & "|" & $strNamespace
	Next

	GUICtrlSetData($GUI_WMI_Namespace, $strNameSpacesCombo, "ROOT\CIMV2")

EndFunc   ;==>LoadWMINamespaces

;********************************************************************
;* EnumNamespaces
;********************************************************************
Func EnumNamespaces($strNamespace, ByRef $tmpCsvListOfNamespaces)

	If $tmpCsvListOfNamespaces = "" Then
		$tmpCsvListOfNamespaces = $strNamespace
	Else
		$tmpCsvListOfNamespaces = $tmpCsvListOfNamespaces & "," & $strNamespace
	EndIf

	Local $strComputer = $g_strWMISource
	Local $objWMIService = ObjGet("winmgmts:\\" & $g_strWMISource & "\" & $strNamespace)

	If Not @error Then

		Local $colNameSpaces = $objWMIService.InstancesOf("__NAMESPACE")

		For $objNameSpace In $colNameSpaces
			EnumNamespaces($strNamespace & "\" & $objNameSpace.Name, $tmpCsvListOfNamespaces)
		Next
	Else
		$tmpCsvListOfNamespaces = ""
	EndIf

EndFunc   ;==>EnumNamespaces

;********************************************************************
;* HandleNamespaceChange
;********************************************************************
Func HandleNamespaceChange()

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Clear the WMI classes pulldown location.
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	Local $strSelectedNamespace = GUICtrlRead($GUI_WMI_Namespace)

	; Disable the namespace combobox until class load has been completed
	GUICtrlSetState($GUI_WMI_Namespace, $GUI_DISABLE)

	Local $strWMIWaitMsg = "请稍候, 尝试载入命名空间里面的'类'(class)" & $strSelectedNamespace
	GUICtrlSetData($GUI_WMI_Classes, $strWMIWaitMsg, $strWMIWaitMsg)
	GUICtrlSetData($GUI_AST_ScriptCode, "载入中,请等待一会儿...", "")

	LoadWMIClasses()
	$g_strCurrentNamespace = "\" & $strSelectedNamespace

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Clear the code textarea and disable run and save.
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	GUICtrlSetData($GUI_AST_ScriptCode, "", "")

	GUICtrlSetState($GUI_WMI_Namespace, $GUI_ENABLE)
	GUICtrlSetState($GUI_AST_Run, $GUI_DISABLE)
	GUICtrlSetState($GUI_AST_Save, $GUI_DISABLE)

EndFunc   ;==>HandleNamespaceChange

;********************************************************************
;* LoadWMIClasses
;*
;* Fetch all the classes in the currently selected namespace, and
;* populate the keys of a dictionary object with the names of all
;* dynamic (non-association) classes. Then we transfer the keys to
;* an array, sort the array, and finally use the sorted array to
;* populate the WMI classes pulldown.
;********************************************************************
Func LoadWMIClasses()

	Const $SORT_KEYS = 1
	Const $SORT_ITEMS = 2

	Local $objClassDictionary = ObjCreate("Scripting.Dictionary")
	Local $objQualifierDictionary = ObjCreate("Scripting.Dictionary")

	Local $strComputer = "."
	Local $objWMIService = ObjGet("winmgmts:\\" & $strComputer & $g_strCurrentNamespace)

	If Not @error Then

		For $objClass In $objWMIService.SubclassesOf()

			For $objQualifier In $objClass.Qualifiers_() ; Dummy (), because it ends with an underscore !
				$objQualifierDictionary.Add(StringLower($objQualifier.Name), "")
			Next

			If $objQualifierDictionary.Exists("dynamic") Then

				;$TempVar = $objClass.Path_.Class
				;$objClassDictionary.Add($TempVar, "")	; Can't use object in arguments ?!!

				$objClassDictionary.Add($objClass.Path_.Class, "")

			EndIf

			$objQualifierDictionary.RemoveAll

		Next

		$objQualifierDictionary = ""

		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; If the current namespace contains dynamic classes...
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		If $objClassDictionary.Count Then

			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			; Sort the dictionary.
			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			SortDictionary($objClassDictionary, $SORT_KEYS)

			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
			; Populate the WMI classes pulldown with the sorted dictionary.
			;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

			Local $strClassesCombo = "|选择一个 WMI 类('class')"

			For $strWMIClass In $objClassDictionary ;  method .Keys is not an object ??
				$strClassesCombo = $strClassesCombo & "|" & $strWMIClass
			Next

			GUICtrlSetData($GUI_WMI_Classes, $strClassesCombo, "选择一个 WMI 类('class')")

		EndIf
	EndIf

	If @error Or $objClassDictionary.Count = 0 Then
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; And if the current namespace doesn't contain dynamic classes.
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		GUICtrlSetData($GUI_WMI_Classes, "|没有在当前命名空间找到动态的类.|选择一个不同的命名空间", "")

	EndIf

	$objClassDictionary = ""

EndFunc   ;==>LoadWMIClasses

;********************************************************************
;* SortDictionary
;*
;* Shell sort based on:
;* http://support.microsoft.com/support/kb/articles/q246/0/67.asp
;********************************************************************
Func SortDictionary(ByRef $objDict, $intSort)

	Const $dictKey = 1
	Const $dictItem = 2

	Dim $strDict[1][3]

	Local $intCount = $objDict.Count

	If $intCount > 1 Then

		ReDim $strDict[$intCount][3]

		Local $i = 0
		For $objKey In $objDict

			$strDict[$i][$dictKey] = String($objKey)
			$strDict[$i][$dictItem] = String($objDict($objKey))

			$i = $i + 1
		Next

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Perform a shell sort of the 2D string array
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		For $i = 0 To ($intCount - 2)
			For $j = $i To ($intCount - 1)
				If $strDict[$i][$intSort] > $strDict[$j][$intSort] Then
					Local $strKey = $strDict[$i][$dictKey]
					Local $strItem = $strDict[$i][$dictItem]
					$strDict[$i][$dictKey] = $strDict[$j][$dictKey]
					$strDict[$i][$dictItem] = $strDict[$j][$dictItem]
					$strDict[$j][$dictKey] = $strKey
					$strDict[$j][$dictItem] = $strItem
				EndIf
			Next
		Next

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Erase the contents of the dictionary object
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		$objDict.RemoveAll

		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Repopulate the dictionary with the sorted information
		;''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		For $i = 0 To ($intCount - 1)
			$objDict.Add($strDict[$i][$dictKey], $strDict[$i][$dictItem])
		Next

	EndIf

EndFunc   ;==>SortDictionary

;********************************************************************
;* ComposeCode
;********************************************************************
Func ComposeCode()

	Local $objClass = ""

	Local $strSelectedClass = GUICtrlRead($GUI_WMI_Classes)
	; Check if a valid class has been selected
	If $strSelectedClass <> "选择一个 WMI 类('class')" Then

		Local $bHasDates = False ; Flag: output has date fields
		Local $strHeaderStart = Chr(34)
		Local $strRowStart = Chr(34)
		Local $strColumnSeparator = ": "
		Local $strRowEnd = " & @CRLF"


		Local $strComputerCommand = "	Local $strComputer = " & Chr(34) & $g_strWMISource & Chr(34)

		Local $objWMIService = ObjGet("winmgmts:{impersonationLevel=impersonate}!\\" & @ComputerName & $g_strCurrentNamespace)
		$objClass = $objWMIService.Get($strSelectedClass)

		If IsObj($objClass) Then

			Local $strScriptCode = ""
			$strScriptCode &= "; 生成于 AutoIt Scriptomatic" & @CRLF & @CRLF
			$strScriptCode &= "__wmi_" & $strSelectedClass & "()" & @CRLF
			$strScriptCode &= "Func __wmi_" & $strSelectedClass & "()" & @CRLF
			$strScriptCode &= "	Local $wbemFlagReturnImmediately = 0x10" & @CRLF
			$strScriptCode &= "	Local $wbemFlagForwardOnly = 0x20" & @CRLF
			$strScriptCode &= '	Local $colItems = ""' & @CRLF
			$strScriptCode &= $strComputerCommand & @CRLF & @CRLF
			$strScriptCode &= '	Local $Output=""' & @CRLF

			If $g_strOutputFormat = "HTML" Then
				$strScriptCode = $strScriptCode & "$Output = $Output & '<html><head><title>Scriptomatic HTML Output</title></head><body> " & _
						"<style>table {font-size: 10pt; font-family: arial;} th {background-color: buttonface; font-decoration: bold;} " & _
						"</style><table BORDER=" & Chr(34) & "1" & Chr(34) & "><tr><th>Property</th><th>Value</th></tr>'" & @CRLF
				$strRowStart = Chr(34) & "<tr><td>"
				$strHeaderStart = "'<tr bgcolor=" & Chr(34) & "yellow" & Chr(34) & "><td>' & " & Chr(34)
				$strColumnSeparator = "</td><td>&nbsp;"
				$strRowEnd = " & " & Chr(34) & "</td></tr>" & Chr(34) & " & @CRLF"
			EndIf

			$strScriptCode &= "	$Output &= " & $strHeaderStart & "Computer" & $strColumnSeparator & Chr(34) & " & $strComputer " & $strRowEnd & @CRLF

			If $g_strOutputFormat = "Dialog" Then
				$strScriptCode &= "	$Output &= " & Chr(34) & "==========================================" & Chr(34) & $strRowEnd & @CRLF
			EndIf

			$strScriptCode &= "	Local $objWMIService = ObjGet(" & Chr(34) & "winmgmts:\\" & Chr(34) & " & $strComputer & " & Chr(34) & $g_strCurrentNamespace & Chr(34) & ")" & @CRLF
			$strScriptCode &= "	$colItems = $objWMIService.ExecQuery(" & Chr(34) & "SELECT * FROM " & $strSelectedClass & Chr(34) & ", " & Chr(34) & "WQL" & Chr(34) & ", _" & @CRLF
			$strScriptCode &= "                                          $wbemFlagReturnImmediately + $wbemFlagForwardOnly)" & @CRLF & @CRLF
			$strScriptCode &= "	If IsObj($colItems) then" & @CRLF
			$strScriptCode &= "	   For $objItem In $colItems" & @CRLF

			For $objProperty In $objClass.Properties_() ; Must use (), because method ends with an underscore

				If $objProperty.IsArray = True Then
					$strScriptCode &= "		     Local $str" & $objProperty.Name & " = $objItem." & $objProperty.Name & "(0)" & @CRLF
					$strScriptCode &= "	      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & $str" & $objProperty.Name & $strRowEnd & @CRLF
				ElseIf $objProperty.CIMTYPE = 101 Then
					$bHasDates = True
					$strScriptCode &= "	      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & WMIDateStringToDate($objItem." & $objProperty.Name & ")" & $strRowEnd & @CRLF
				Else
					$strScriptCode &= "	      $Output &= " & $strRowStart & $objProperty.Name & $strColumnSeparator & Chr(34) & " & $objItem." & $objProperty.Name & $strRowEnd & @CRLF
				EndIf
			Next

			If $g_strOutputFormat = "Dialog" Then
				$strScriptCode &= '	      if Msgbox(1,"WMI Output",$Output) = 2 then ExitLoop' & @CRLF
				$strScriptCode &= '	      $Output=""' & @CRLF
			EndIf
			$strScriptCode = $strScriptCode & "	   Next" & @CRLF

			If $g_strOutputFormat = "Text" Then
				$strScriptCode &= '   ConsoleWrite($Output)' & @CRLF
				$strScriptCode &= '   FileWrite(@TempDir & "\' & $strSelectedClass & '.TXT", $Output )' & @CRLF
				$strScriptCode &= '   Run(@Comspec & " /c start " & @TempDir & "\' & $strSelectedClass & '.TXT" )' & @CRLF
			ElseIf $g_strOutputFormat = "HTML" Then
				$strScriptCode &= '   FileWrite(@TempDir & "\' & $strSelectedClass & '.HTML", $Output )' & @CRLF
				$strScriptCode &= '   Run(@Comspec & " /c start " & @TempDir & "\' & $strSelectedClass & '.HTML" )' & @CRLF
			EndIf

			$strScriptCode &= "	Else" & @CRLF
			$strScriptCode &= '	   Msgbox(0,"WMI 输出","没有在类 " & ' & Chr(34) & $strSelectedClass & Chr(34) & ' & "中找到WMI对象" )' & @CRLF

			$strScriptCode &= "	Endif" & @CRLF
			$strScriptCode &= "EndFunc" & @CRLF
			$strScriptCode &= @CRLF & @CRLF

			If $bHasDates Then
				$strScriptCode &= "Func WMIDateStringToDate($dtmDate)" & @CRLF
				$strScriptCode &= @CRLF
				$strScriptCode &= Chr(9) & "Return (StringMid($dtmDate, 5, 2) & ""/"" & _" & @CRLF
				$strScriptCode &= Chr(9) & "StringMid($dtmDate, 7, 2) & ""/"" & StringLeft($dtmDate, 4) _" & @CRLF
				$strScriptCode &= Chr(9) & "& "" "" & StringMid($dtmDate, 9, 2) & "":"" & StringMid($dtmDate, 11, 2) & "":"" & StringMid($dtmDate,13, 2))" & @CRLF
				$strScriptCode &= "EndFunc"
			EndIf
		Else
			$strScriptCode = "错误: 没有发现类属性:" & $g_strCurrentNamespace & "\" & $strSelectedClass
		EndIf

		GUICtrlSetData($GUI_AST_ScriptCode, $strScriptCode)

		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		; Once the code is successfully composed and put into the
		; textarea, ensure that the run and save buttons are enabled.
		;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
		GUICtrlSetState($GUI_AST_Run, $GUI_ENABLE)
		GUICtrlSetState($GUI_AST_Save, $GUI_ENABLE)

	Else
		; Disable Run and Save buttons, because no valid code has been generated
		GUICtrlSetState($GUI_AST_Run, $GUI_DISABLE)
		GUICtrlSetState($GUI_AST_Save, $GUI_DISABLE)
	EndIf

EndFunc   ;==>ComposeCode


;********************************************************************
;* RunScript
;********************************************************************
Func RunScript()

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Create a temporary script file named "temp_script.au3".
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

	Local $strTmpName = @TempDir & "\temp_script.au3"

	If FileExists($strTmpName) Then FileDelete($strTmpName)

	FileWrite($strTmpName, GUICtrlRead($GUI_AST_ScriptCode))

	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	; Start constructing the command line that will run the script...
	;'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
	Local $strCmdLine = @AutoItExe & " /AutoIt3ExecuteScript " & $strTmpName

	RunWait($strCmdLine)

	FileDelete($strTmpName)

EndFunc   ;==>RunScript


;********************************************************************
;* SaveScript
;********************************************************************
Func SaveScript()

	Local $strTmpName = FileSaveDialog("保存脚本", @DesktopDir, "AutoIt3 脚本 (*.au3)", 16, GUICtrlRead($GUI_WMI_Classes))

	If Not @error And $strTmpName <> "" Then
		If StringRight($strTmpName, 4) <> ".AU3" Then $strTmpName = $strTmpName & ".AU3"
		If FileExists($strTmpName) Then FileDelete($strTmpName)
		FileWrite($strTmpName, GUICtrlRead($GUI_AST_ScriptCode))
	EndIf

EndFunc   ;==>SaveScript


;********************************************************************
;* OpenScript
;********************************************************************

Func OpenScript()

	Local $strTmpName = FileOpenDialog("打开脚本", @DesktopDir, "AutoIt3 脚本 (*.au3)")

	If Not @error And $strTmpName <> "" Then
		If FileExists($strTmpName) Then
			GUICtrlSetData($GUI_AST_ScriptCode, FileRead($strTmpName, FileGetSize($strTmpName)))
		EndIf
	EndIf

EndFunc   ;==>OpenScript


;****************************************************************************
;* SetNamespaceToCIMV2
;****************************************************************************
Func SetNamespaceToCIMV2()
	If StringUpper(GUICtrlRead($GUI_WMI_Namespace)) <> "ROOT\CIMV2" Then
		GUICtrlSetData($GUI_WMI_Namespace, "ROOT\CIMV2", "ROOT\CIMV2")
		HandleNamespaceChange()
	EndIf
EndFunc   ;==>SetNamespaceToCIMV2

;****************************************************************************
;* SetWMIRepository
;****************************************************************************
Func SetWMIRepository()

	Local $strWMISourceName = InputBox("Set WMI Repository Source", _
			"Please enter the computer whose WMI repository you want to read from: ", _
			$g_strWMISource)
	If $strWMISourceName <> "" Then

		$g_strWMISource = StringStripWS($strWMISourceName, 1 + 2)
		;target_computers.Value = $g_strWMISource
		LoadWMINamespaces()
	EndIf
EndFunc   ;==>SetWMIRepository

;****************************************************************************
;* HandleOutputChange
;****************************************************************************
Func HandleOutputChange()

	Local $ChosenFormat = $g_strOutputFormat
	If GUICtrlRead($GUI_AST_RadioDialog) = $GUI_CHECKED Then $ChosenFormat = "对话框"
	If GUICtrlRead($GUI_AST_RadioText) = $GUI_CHECKED Then $ChosenFormat = "文本"
	If GUICtrlRead($GUI_AST_RadioHTML) = $GUI_CHECKED Then $ChosenFormat = "HTML"
	If $ChosenFormat <> $g_strOutputFormat Then
		$g_strOutputFormat = $ChosenFormat
		ComposeCode()
	EndIf
EndFunc   ;==>HandleOutputChange